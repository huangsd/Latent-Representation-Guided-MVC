function [pre_y, S] = RMVCStrucGra(data, labels, r, alpha, eta, knn)
%
% Code for the following problem:
% min_{U_i,V,S} \sum_i\mu^i||X^1- U^iV'||_{2,1} + \eta(\sum_{ij}||v_i-v_j||_2^2s_{ij}+\gamma s_{ij}^2) 
% s.t. s1 = 1, S >= 0, rank(L) = n-c, V >=0, V'V = I
%
% ATTN1: This package is free for academic usage. The code was developed by Shudong Huang. You can run
% it at your own risk. For other purposes, please contact huangsd@scu.edu.cn
%
% ATTN2: This package was developed by ***. For any problem concerning the code, please feel
% free to contact huangsd@scu.edu.cn (Dr. Huang).
%
% Inputs:
%   data - a cell array, view_num*1, each array is n*d_v
%   numC - number of clusters
%   view_num - number of views
%   numSmp - number of samples (instances)
%   knn - number of adaptive neighbours
%   labels - a column vector, groundtruth of the data, num by 1
%   knn - number of k-nearest neighbors (set knn=0 if using fully connected graph)
%
%  Optional Inputs:
%   tol, tol2 - the tolerance that determines convergence of algorithm
%
% Outputs:
%   res - clustering results (normalized mutual information, ACC, Purity)
%   label - label generated by spectral clustering on the learned unified graph
%   S: target structured graph with explicit cluster structure
%
% Written by: *** (***)
% 2020/07/30
%
%
% Example: 
% [res, S] = RMVCStrucGra(data, labels, length(unique(labels)), 1, 1);
% 
% eta_para = [0.001,0.01,0.1,1,10];
% alpha_para = [0.1,1,10,100,1000];
%
if nargin < 6
    knn = 10;
end
if nargin < 5
    eta = 1;
end
if nargin < 4
   alpha = 1; 
end
if nargin < 3
   r = length(unique(labels)); 
end
% number of data samples
numSmp = length(labels);
% number of clusters
numC = length(unique(labels));
% number of views
numView = length(data);
% normalization
for i = 1:numView
    for  j = 1:numSmp
        data{i}(j,:) = (data{i}(j,:) - mean(data{i}(j,:)))/std(data{i}(j,:) ) ;
    end
end
numFea = zeros(1,numView);
for i = 1:numView
    data{i} = data{i}'; % d_v*n
    numFea(i) = size(data{i},1);
    %data{i} = NormalizeFea(data{i},0);
end

% \alpha and \lambda
lambda = randperm(30,1);
% weight \mu
mu = ones(numView,1) / numView;

% ALM parameters and E
Lambda = zeros(numSmp,r);
Lambda_v = cell(1,numView);
for i = 1:numView
    Lambda_v{i} = zeros(size(data{i}));
end
E = cell(1,numView);
% for i = 1:numView
%     E{i} = data{i} - U{i}*VV{i};
% end

V = zeros(numSmp,r);
idx_V = kmeans(data{1}', r, 'emptyaction', 'singleton');
for i = 1:numSmp
    V(i,idx_V(i)) = 1;
end
V = V + 0.2; % numerical stability purpose    
% for j = 1:numSmp
%     V(j,:) = (V(j,:) - mean(V(j,:)))/std(V(j,:) ) ;
% end
    
U = cell(1,numView);
for i = 1:numView
    idx_U = kmeans(data{i}, r, 'emptyaction', 'singleton');
    U{i} = zeros(numFea(i), r);
    for j = 1:numFea(i)
        U{i}(j,idx_U(j)) = 1;
    end
    U{i} = U{i} + 0.2; 
end
% for i = 1:numView
%     for  j = 1:numFea(i)
%         U{i}(j,:) = (U{i}(j,:) - mean(U{i}(j,:)))/std(U{i}(j,:) ) ;
%     end
% end


%initialize S
% SUM = zeros(numSmp);
% for i = 1:numView
%     distX_initial(:,:,i) =  L2_distance_1(data{i},data{i}) ;                 
%     SUM = SUM + distX_initial(:,:,i);
% end
% distX = SUM/numView;
distX = L2_distance_1(V',V'); 
[distXs, idx] = sort(distX,2);
S = zeros(numSmp);
rr = zeros(numSmp,1);
for i = 1:numSmp
    di = distXs(i,2:knn+2);
    rr(i) = 0.5*(knn*di(knn+1)-sum(di(1:knn)));
    id = idx(i,2:knn+2);
    S(i,id) = (di(knn+1)-di)/(knn*di(knn+1)-sum(di(1:knn))+eps);              
end;
gamma = mean(rr);

% initialize F
S = (S+S')/2;                                                         % initialize F
D = diag(sum(S));
Ls = D - S;
[F, temp, evs]=eig1(Ls, numC, 0);

ITER = 50;
for iter = 1:ITER
    
    % update E
    P = cell(1,numView);
    for i = 1:numView
        P{i} = data{i} - U{i}*V' + (1/alpha)*Lambda_v{i};
    end
    for i = 1:numView
        E{i} = L21_solver(P{i},mu(i)/alpha);
    end
    
    % update U
    for i = 1:numView
        U{i} = (data{i}-E{i}+(1/alpha)*Lambda_v{i})*V;
    end
    
    % update Z
    Z = max(V + (1/alpha)*Lambda - (2*eta/alpha)*Ls*V,0);
    
    % update V
    Q = zeros(numSmp,r);
    temp1 = (1/numView)*(Z - (1/alpha)*Lambda);
    temp2 = ((2*eta)/(numView*alpha))*Ls*Z;
    for i = 1:numView
        Q = Q + ((data{i}-E{i}+(1/alpha)*Lambda_v{i})'*U{i} + temp1)/(1 + (1/numView)) - temp2;
    end
    [W O H] =  mySVD(Q/numView,0);
    % [W O H] = svd(Q/numView,'econ');
    V = W*H';
    
    % update \mu
      % tmp = 1/(1-r);
    for i = 1:numView        
        temp = (data{i}-U{i}*V')';
        temp1 = sqrt(sum(temp.*temp, 2));
        temp2(i) =  sum(temp1);
        mu(i) = 0.5/sqrt(sum(temp1));
        
    end
    % mu = ((r*temp2).^tmp)/(sum(((r*temp2).^tmp)));
      
    % update S
    S = updateS(Z, V, F, knn, lambda, eta);  
       

    % update F
    S = (S+S')/2;                                                        
    D = diag(sum(S));
    Ls = D-S;
    F_old = F;
    [F, temp, ev]=eig1(Ls, numC, 0);
    evs(:,iter+1) = ev;
    
    
    %update lambda
    thre = 1*10^-10;
    fn1 = sum(ev(1:numC));                                               
    fn2 = sum(ev(1:numC+1));
    if fn1 > thre
        lambda = 2*lambda;
    elseif fn2 < thre
        lambda = lambda/2;  
        F = F_old;
    else
        break;
    end;
    % sprintf('iter = %d',iter)
    

    % update ALM parameters 
    Lambda = Lambda + alpha*(V - Z);
    for i = 1:numView
        Lambda_v{i} = Lambda_v{i} + alpha*(data{i}-U{i}*V'-E{i});
    end
    
    % update alpha
    alpha = alpha*1.25; 
end

[clusternum, y]=graphconncomp(sparse(S)); 
pre_y = y';
if clusternum ~= numC
    sprintf('Can not find the correct cluster number: %d', numC)
end;

end


% min ||X-FG||_{2,1}
% s.t. F>0, G>0
function [G, F] = L21NMF(X, r)
% X: mfea * nSmp 
% G: k * nSmp
% F: mfea * k
% % =====================   Normalization =====================
[mfea, nSmp] = size(X);
% for  j = 1:nSmp
%      X(j,:) = ( X(j,:) - mean( X(j,:) ) ) / std( X(j,:) ) ;
% end
% X = mapminmax(X,0,1);
D = eye(nSmp, nSmp);

% G = abs(rand(r,nSmp));
% F = abs(rand(mfea,r));

Gres = kmeans(X', r, 'emptyaction', 'singleton'); % length(unique(labels))
G = zeros(nSmp,r);
for i = 1:nSmp
    G(i,Gres(i)) = 1;
end
G = G+0.2;
G = G';

Fres = kmeans(X, r, 'emptyaction', 'singleton');
F = zeros(mfea,r);
for i = 1:mfea
    F(i,Fres(i)) = 1;
end
F = F+0.2;



for iter = 1:20
    
    F = F.*((X*D*G')./(F*G*D*G'+eps));
    
    G = G.*((F'*X*D)./(F'*F*G*D+eps));
    
    
    Delta = X - F*G;
    DeltaN = sqrt(sum(Delta.*Delta, 1));
%     
%     if it == 1
%         DeltaS = sort(DeltaN);
%         len = length(DeltaS);
%         theta = DeltaS(floor(ratio*len))
%     end
%     

    DiagD = 0.5./(DeltaN+eps);
   % Idx = find(DeltaN>theta);
   % DiagD(Idx) = 0;
    D = diag(DiagD);
    
    
   % Ei2{v} = sqrt(sum(E{v}.*E{v}, 2) + eps);                

    
       
    %--------obj----------
    T = X - F*G;
    obj = sum(diag(T*D*T'));
    myobj(iter) = obj;  
    
    %fprintf('%d-th iteration, obj = %f\n', iter, obj);
    thresh = 1e-6;
    if iter > 2
        diff = abs(myobj(iter-1) - myobj(iter));
        if(diff < thresh)
            break;
        end
    end
    
end

% G_res = kmeans(G',length(unique(labels)),'emptyaction','singleton');

end


function S = updateS(Z, V, F, knn, lambda, eta)
    numSmp = size(F,1);
    distf = L2_distance_1(F',F');
    distv = L2_distance_1(Z',V');
    
    % [distvfs, idx] = sort(distv+lambda*distf,2);
    [distvs, idx] = sort(distv,2);
    rr = zeros(numSmp,1);
    for i = 1:numSmp
        di = distvs(i,2:knn+2);
        rr(i) = 0.5*(knn*di(knn+1)-sum(di(1:knn)));              
    end;
    gamma = mean(rr);

    S = zeros(numSmp);
    for i=1:numSmp      
        idxa0 = idx(i,2:knn+1);
        dfi = distf(i,idxa0);
        dvi = distv(i,idxa0);
        ad = -(dvi+(lambda/eta)*dfi)/(2*gamma);
        S(i,idxa0) = EProjSimplex_new(ad);
    end;
    
end









